/**
 * Automatically generated by Zserio C++11 Safe generator version 1.2.1 using Zserio core 2.16.1.
 * Generator setup: writerCode, settersCode, pubsubCode, serviceCode, sqlCode, polymorphicAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/ErrorCode.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <minizs/Inner.h>

namespace minizs
{

::zserio::Result<Inner> Inner::create(::zserio::BitStreamReader& in, const allocator_type& allocator)
{
    Inner inner(allocator);
    
    // Read key
    auto keyResult = in.readString(allocator);
    if (!keyResult.isSuccess())
    {
        return ::zserio::Result<Inner>::error(keyResult.getError());
    }
    inner.m_key_ = keyResult.moveValue();
    
    // Read value
    auto valueResult = in.readBits(UINT8_C(8));
    if (!valueResult.isSuccess())
    {
        return ::zserio::Result<Inner>::error(valueResult.getError());
    }
    inner.m_value_ = static_cast<uint8_t>(valueResult.getValue());
    
    return ::zserio::Result<Inner>::success(std::move(inner));
}

Inner::Inner(const allocator_type& allocator) noexcept :
        m_key_(allocator),
        m_value_(uint8_t())
{
}


Inner::Inner(::zserio::PropagateAllocatorT,
        const Inner& other, const allocator_type& allocator) :
        m_key_(::zserio::allocatorPropagatingCopy(other.m_key_, allocator)),
        m_value_(::zserio::allocatorPropagatingCopy(other.m_value_, allocator))
{
}

::zserio::pmr::string& Inner::getKey()
{
    return m_key_;
}

const ::zserio::pmr::string& Inner::getKey() const
{
    return m_key_;
}

void Inner::setKey(const ::zserio::pmr::string& key_)
{
    m_key_ = key_;
}

void Inner::setKey(::zserio::pmr::string&& key_)
{
    m_key_ = ::std::move(key_);
}

uint8_t Inner::getValue() const
{
    return m_value_;
}

void Inner::setValue(uint8_t value_)
{
    m_value_ = value_;
}

::zserio::Result<size_t> Inner::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    auto stringSizeResult = ::zserio::bitSizeOfString(m_key_);
    if (!stringSizeResult.isSuccess())
    {
        return stringSizeResult;
    }
    endBitPosition += stringSizeResult.getValue();
    endBitPosition += UINT8_C(8);

    return ::zserio::Result<size_t>::success(endBitPosition - bitPosition);
}

::zserio::Result<size_t> Inner::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    auto stringSizeResult = ::zserio::bitSizeOfString(m_key_);
    if (!stringSizeResult.isSuccess())
    {
        return stringSizeResult;
    }
    endBitPosition += stringSizeResult.getValue();
    endBitPosition += UINT8_C(8);

    return ::zserio::Result<size_t>::success(endBitPosition);
}

bool Inner::operator==(const Inner& other) const
{
    if (this != &other)
    {
        return
                (m_key_ == other.m_key_) &&
                (m_value_ == other.m_value_);
    }

    return true;
}

bool Inner::operator<(const Inner& other) const
{
    if (m_key_ < other.m_key_)
    {
        return true;
    }
    if (other.m_key_ < m_key_)
    {
        return false;
    }

    if (m_value_ < other.m_value_)
    {
        return true;
    }
    if (other.m_value_ < m_value_)
    {
        return false;
    }

    return false;
}

uint32_t Inner::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, m_key_);
    result = ::zserio::calcHashCode(result, m_value_);

    return result;
}

::zserio::Result<void> Inner::write(::zserio::BitStreamWriter& out) const
{
    auto result = out.writeString(m_key_);
    if (!result.isSuccess())
    {
        return result;
    }
    
    result = out.writeBits(m_value_, UINT8_C(8));
    if (!result.isSuccess())
    {
        return result;
    }
    
    return ::zserio::Result<void>::success();
}

::zserio::pmr::string Inner::readKey(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    auto result = in.readString(allocator);
    if (!result.isSuccess())
    {
        // In production code, we'd need better error handling here
        // For now, return empty string on error
        return ::zserio::pmr::string(allocator);
    }
    return result.getValue();
}

uint8_t Inner::readValue(::zserio::BitStreamReader& in)
{
    auto result = in.readBits(UINT8_C(8));
    if (!result.isSuccess())
    {
        // In production code, we'd need better error handling here
        // For now, return 0 on error
        return 0;
    }
    return static_cast<uint8_t>(result.getValue());
}


} // namespace minizs
