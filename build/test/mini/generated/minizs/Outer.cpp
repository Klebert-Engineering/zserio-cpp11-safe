/**
 * Automatically generated by Zserio C++11 Safe generator version 1.2.1 using Zserio core 2.16.1.
 * Generator setup: writerCode, settersCode, pubsubCode, serviceCode, sqlCode, polymorphicAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/ErrorCode.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>
#include <zserio/Result.h>

#include <minizs/Outer.h>

namespace minizs
{

::zserio::Result<Outer> Outer::create(::zserio::BitStreamReader& in, uint8_t numOfInners_, const allocator_type& allocator)
{
    Outer outer(allocator);
    outer.m_numOfInners_ = numOfInners_;
    outer.m_isInitialized = true;
    
    // Read array
    auto readResult = outer.m_inner_.read(outer, in, static_cast<size_t>(numOfInners_));
    if (!readResult.isSuccess())
    {
        return ::zserio::Result<Outer>::error(readResult.getError());
    }
    
    return ::zserio::Result<Outer>::success(std::move(outer));
}

Outer::Outer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_inner_(allocator)
{
}


Outer::Outer(const Outer& other) :
        m_inner_(other.m_inner_)
{
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }
}

Outer& Outer::operator=(const Outer& other)
{
    m_inner_ = other.m_inner_;
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }

    return *this;
}

Outer::Outer(Outer&& other) :
        m_inner_(::std::move(other.m_inner_))
{
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }
}

Outer& Outer::operator=(Outer&& other)
{
    m_inner_ = ::std::move(other.m_inner_);
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }

    return *this;
}

Outer::Outer(::zserio::NoInitT,
        const Outer& other) :
        m_isInitialized(false),
        m_inner_(other.m_inner_)
{
}

Outer& Outer::assign(::zserio::NoInitT,
        const Outer& other)
{
    m_isInitialized = false;
    m_inner_ = other.m_inner_;

    return *this;
}

Outer::Outer(::zserio::NoInitT,
        Outer&& other) :
        m_isInitialized(false),
        m_inner_(::std::move(other.m_inner_))
{
}

Outer& Outer::assign(::zserio::NoInitT,
        Outer&& other)
{
    m_isInitialized = false;
    m_inner_ = ::std::move(other.m_inner_);

    return *this;
}

Outer::Outer(::zserio::PropagateAllocatorT,
        const Outer& other, const allocator_type& allocator) :
        m_inner_(::zserio::allocatorPropagatingCopy(other.m_inner_, allocator))
{
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }
}

Outer::Outer(::zserio::PropagateAllocatorT, ::zserio::NoInitT,
        const Outer& other, const allocator_type& allocator) :
        m_isInitialized(false),
        m_inner_(::zserio::allocatorPropagatingCopy(other.m_inner_, allocator))
{
}

void Outer::initialize(
        uint8_t numOfInners_)
{
    m_numOfInners_ = numOfInners_;
    m_isInitialized = true;
}

bool Outer::isInitialized() const
{
    return m_isInitialized;
}

uint8_t Outer::getNumOfInners() const
{
    // Note: In a fully safe implementation, this should return Result<uint8_t>
    // For now, we'll return 0 if not initialized to avoid throwing
    if (!m_isInitialized)
    {
        return 0;
    }

    return m_numOfInners_;
}

::zserio::pmr::vector<::minizs::Inner>& Outer::getInner()
{
    return m_inner_.getRawArray();
}

const ::zserio::pmr::vector<::minizs::Inner>& Outer::getInner() const
{
    return m_inner_.getRawArray();
}

void Outer::setInner(const ::zserio::pmr::vector<::minizs::Inner>& inner_)
{
    m_inner_ = ZserioArrayType_inner(inner_);
}

void Outer::setInner(::zserio::pmr::vector<::minizs::Inner>&& inner_)
{
    m_inner_ = ZserioArrayType_inner(std::move(inner_));
}

::zserio::Result<size_t> Outer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    auto innerSizeResult = m_inner_.bitSizeOf(*this, endBitPosition);
    if (!innerSizeResult.isSuccess())
    {
        return innerSizeResult;
    }
    endBitPosition += innerSizeResult.getValue();

    return ::zserio::Result<size_t>::success(endBitPosition - bitPosition);
}

::zserio::Result<size_t> Outer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    auto innerOffsetResult = m_inner_.initializeOffsets(*this, endBitPosition);
    if (!innerOffsetResult.isSuccess())
    {
        return innerOffsetResult;
    }
    endBitPosition = innerOffsetResult.getValue();

    return ::zserio::Result<size_t>::success(endBitPosition);
}

bool Outer::operator==(const Outer& other) const
{
    if (this != &other)
    {
        return
                (getNumOfInners() == other.getNumOfInners()) &&
                (m_inner_ == other.m_inner_);
    }

    return true;
}

bool Outer::operator<(const Outer& other) const
{
    if (getNumOfInners() < other.getNumOfInners())
    {
        return true;
    }
    if (other.getNumOfInners() < getNumOfInners())
    {
        return false;
    }

    if (m_inner_ < other.m_inner_)
    {
        return true;
    }
    if (other.m_inner_ < m_inner_)
    {
        return false;
    }

    return false;
}

uint32_t Outer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumOfInners());
    result = ::zserio::calcHashCode(result, m_inner_);

    return result;
}

::zserio::Result<void> Outer::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_inner_.getRawArray().size() != static_cast<size_t>(getNumOfInners()))
    {
        return ::zserio::Result<void>::error(::zserio::ErrorCode::ConstraintViolation);
    }
    return m_inner_.write(*this, out);
}

::zserio::Result<void> Outer::ZserioElementFactory_inner::create(Outer&,
        ::zserio::pmr::vector<::minizs::Inner>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    auto innerResult = Inner::create(in, array.get_allocator());
    if (!innerResult.isSuccess())
    {
        return ::zserio::Result<void>::error(innerResult.getError());
    }
    array.push_back(innerResult.moveValue());
    return ::zserio::Result<void>::success();
}

Outer::ZserioArrayType_inner Outer::readInner(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_inner readField(allocator);
    auto result = readField.read(*this, in, static_cast<size_t>(getNumOfInners()));
    if (!result.isSuccess())
    {
        // In production code, we'd need better error handling here
        // For now, return empty array on error
        return ZserioArrayType_inner(allocator);
    }

    return readField;
}


} // namespace minizs
