/**
 * Automatically generated by Zserio C++11 Safe generator version 1.2.1 using Zserio core 2.16.1.
 * Generator setup: writerCode, settersCode, pubsubCode, serviceCode, sqlCode, stdAllocator.
 */

#include <zserio/StringConvertUtil.h>
#include <zserio/ErrorCode.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/BitPositionUtil.h>
#include <zserio/BitSizeOfCalculator.h>
#include <zserio/BitFieldUtil.h>

#include <minizs/Outer.h>

namespace minizs
{

Outer::Outer(const allocator_type& allocator) noexcept :
        m_isInitialized(false),
        m_inner_(allocator)
{
}

Outer::Outer(::zserio::BitStreamReader& in,
        uint8_t numOfInners_, const allocator_type& allocator) :
        m_numOfInners_(numOfInners_),
        m_isInitialized(true),
        m_inner_(readInner(in, allocator))
{
}

Outer::Outer(const Outer& other) :
        m_inner_(other.m_inner_)
{
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }
}

Outer& Outer::operator=(const Outer& other)
{
    m_inner_ = other.m_inner_;
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }

    return *this;
}

Outer::Outer(Outer&& other) :
        m_inner_(::std::move(other.m_inner_))
{
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }
}

Outer& Outer::operator=(Outer&& other)
{
    m_inner_ = ::std::move(other.m_inner_);
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }

    return *this;
}

Outer::Outer(::zserio::NoInitT,
        const Outer& other) :
        m_isInitialized(false),
        m_inner_(other.m_inner_)
{
}

Outer& Outer::assign(::zserio::NoInitT,
        const Outer& other)
{
    m_isInitialized = false;
    m_inner_ = other.m_inner_;

    return *this;
}

Outer::Outer(::zserio::NoInitT,
        Outer&& other) :
        m_isInitialized(false),
        m_inner_(::std::move(other.m_inner_))
{
}

Outer& Outer::assign(::zserio::NoInitT,
        Outer&& other)
{
    m_isInitialized = false;
    m_inner_ = ::std::move(other.m_inner_);

    return *this;
}

Outer::Outer(::zserio::PropagateAllocatorT,
        const Outer& other, const allocator_type& allocator) :
        m_inner_(::zserio::allocatorPropagatingCopy(other.m_inner_, allocator))
{
    if (other.m_isInitialized)
    {
        initialize(other.m_numOfInners_);
    }
    else
    {
        m_isInitialized = false;
    }
}

Outer::Outer(::zserio::PropagateAllocatorT, ::zserio::NoInitT,
        const Outer& other, const allocator_type& allocator) :
        m_isInitialized(false),
        m_inner_(::zserio::allocatorPropagatingCopy(other.m_inner_, allocator))
{
}

void Outer::initialize(
        uint8_t numOfInners_)
{
    m_numOfInners_ = numOfInners_;
    m_isInitialized = true;
}

bool Outer::isInitialized() const
{
    return m_isInitialized;
}

uint8_t Outer::getNumOfInners() const
{
    if (!m_isInitialized)
    {
        throw ::zserio::CppRuntimeException("Parameter 'numOfInners' of compound 'Outer' is not initialized!");
    }

    return m_numOfInners_;
}

::zserio::vector<::minizs::Inner>& Outer::getInner()
{
    return m_inner_.getRawArray();
}

const ::zserio::vector<::minizs::Inner>& Outer::getInner() const
{
    return m_inner_.getRawArray();
}

void Outer::setInner(const ::zserio::vector<::minizs::Inner>& inner_)
{
    m_inner_ = ZserioArrayType_inner(inner_);
}

void Outer::setInner(::zserio::vector<::minizs::Inner>&& inner_)
{
    m_inner_ = ZserioArrayType_inner(std::move(inner_));
}

size_t Outer::bitSizeOf(size_t bitPosition) const
{
    size_t endBitPosition = bitPosition;

    endBitPosition += m_inner_.bitSizeOf(*this, endBitPosition);

    return endBitPosition - bitPosition;
}

size_t Outer::initializeOffsets(size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition = m_inner_.initializeOffsets(*this, endBitPosition);

    return endBitPosition;
}

bool Outer::operator==(const Outer& other) const
{
    if (this != &other)
    {
        return
                (getNumOfInners() == other.getNumOfInners()) &&
                (m_inner_ == other.m_inner_);
    }

    return true;
}

bool Outer::operator<(const Outer& other) const
{
    if (getNumOfInners() < other.getNumOfInners())
    {
        return true;
    }
    if (other.getNumOfInners() < getNumOfInners())
    {
        return false;
    }

    if (m_inner_ < other.m_inner_)
    {
        return true;
    }
    if (other.m_inner_ < m_inner_)
    {
        return false;
    }

    return false;
}

uint32_t Outer::hashCode() const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, getNumOfInners());
    result = ::zserio::calcHashCode(result, m_inner_);

    return result;
}

void Outer::write(::zserio::BitStreamWriter& out) const
{
    // check array length
    if (m_inner_.getRawArray().size() != static_cast<size_t>(getNumOfInners()))
    {
        throw ::zserio::CppRuntimeException("Write: Wrong array length for field Outer.inner: ") <<
                m_inner_.getRawArray().size() << " != " <<
                static_cast<size_t>(getNumOfInners()) << "!";
    }
    m_inner_.write(*this, out);
}

::zserio::Result<void> Outer::ZserioElementFactory_inner::create(Outer&,
        ::zserio::vector<::minizs::Inner>& array,
        ::zserio::BitStreamReader& in, size_t)
{
    auto innerResult = Inner::create(in, array.get_allocator());
    if (!innerResult.isSuccess())
    {
        return ::zserio::Result<void>::error(innerResult.getError());
    }
    array.push_back(innerResult.moveValue());
    return ::zserio::Result<void>::success();
}

Outer::ZserioArrayType_inner Outer::readInner(::zserio::BitStreamReader& in,
        const allocator_type& allocator)
{
    ZserioArrayType_inner readField(allocator);
    readField.read(*this, in, static_cast<size_t>(getNumOfInners()));

    return readField;
}


} // namespace minizs
