#ifndef ZSERIO_BIT_BUFFER_H_INC
#define ZSERIO_BIT_BUFFER_H_INC

#include <cstddef>
#include <cstring>
#include <type_traits>
#include <vector>

#include "zserio/CppRuntimeException.h"
#include "zserio/HashCodeUtil.h"
#include "zserio/Result.h"
#include "zserio/Span.h"
#include "zserio/Types.h"
#include "zserio/Vector.h"

namespace zserio
{

/**
 * Bits helper structure used as a tag in BitStreamReader and BitStreamWriter constructor to pass number of bits
 * instead of number of bytes.
 */
struct BitsTag
{};

/**
 * Class which holds any bit sequence.
 *
 * Because bit buffer size does not have to be byte aligned (divisible by 8), it's possible that not all bits
 * of the last byte are used. In this case, only most significant bits of the corresponded size are used.
 */
template <typename ALLOC = std::allocator<uint8_t>>
class BasicBitBuffer
{
public:
    static_assert(std::is_same<uint8_t, typename ALLOC::value_type>::value,
            "Allocator with uint8_t value_type is required!");

    using allocator_type = ALLOC;

    /**
     * Get copy of the allocator used for dynamic memory allocations.
     *
     * \return Allocator used for dynamic memory allocations.
     */
    allocator_type get_allocator() const noexcept
    {
        return m_buffer.get_allocator();
    }

    /**
     * Empty constructor - cannot fail.
     *
     * \param allocator Allocator to use for internal vector allocation.
     */
    BasicBitBuffer() noexcept;

    /**
     * Constructor from given allocator - cannot fail.
     *
     * \param allocator Allocator to use for internal vector allocation.
     */
    explicit BasicBitBuffer(const ALLOC& allocator) noexcept;

    /**
     * Factory method for creating bit buffer with given bit size.
     *
     * \param bitSize Size in bits of created bit buffer.
     * \param allocator Allocator to use for internal vector allocation.
     * \return Result containing BitBuffer on success or error code on failure.
     */
    static Result<BasicBitBuffer> create(size_t bitSize, const ALLOC& allocator = ALLOC()) noexcept;

    /**
     * Factory method for creating bit buffer from span.
     *
     * \param buffer Span of bytes from which the bit buffer should be created.
     * \param allocator Allocator to use for internal vector allocation.
     * \return Result containing BitBuffer on success or error code on failure.
     */
    static Result<BasicBitBuffer> fromSpan(Span<const uint8_t> buffer, const ALLOC& allocator = ALLOC()) noexcept;

    /**
     * Factory method for creating bit buffer from span with validation.
     *
     * \param buffer Span of bytes from which the bit buffer should be created.
     * \param bitSize Number of bits stored in buffer to use.
     * \param allocator Allocator to use for internal vector allocation.
     * \return Result containing BitBuffer on success or error code on failure.
     */
    static Result<BasicBitBuffer> fromSpan(Span<const uint8_t> buffer, size_t bitSize, const ALLOC& allocator = ALLOC()) noexcept;

    /**
     * Factory method for creating bit buffer from moved STL vector.
     *
     * \param buffer STL vector of bytes from which the bit buffer should be created.
     * \return Result containing BitBuffer on success or error code on failure.
     */
    static Result<BasicBitBuffer> fromVector(vector<uint8_t, ALLOC>&& buffer) noexcept;

    /**
     * Factory method for creating bit buffer from moved STL vector with validation.
     *
     * \param buffer STL vector of bytes from which the bit buffer should be created.
     * \param bitSize Number of bits stored in buffer to use.
     * \return Result containing BitBuffer on success or error code on failure.
     */
    static Result<BasicBitBuffer> fromVector(vector<uint8_t, ALLOC>&& buffer, size_t bitSize) noexcept;

    /**
     * Factory method for creating bit buffer from raw pointer.
     *
     * \param buffer Raw pointer to all bytes from which the bit buffer should be created.
     * \param bitSize Number of bits stored in buffer to use.
     * \param allocator Allocator to use for internal vector allocation.
     * \return Result containing BitBuffer on success or error code on failure.
     */
    static Result<BasicBitBuffer> fromBuffer(const uint8_t* buffer, size_t bitSize, const ALLOC& allocator = ALLOC()) noexcept;

    /**
     * Method generated by default.
     * \{
     */
    ~BasicBitBuffer() = default;

    BasicBitBuffer(const BasicBitBuffer<ALLOC>&) = default;
    BasicBitBuffer(const BasicBitBuffer<ALLOC>& other, const ALLOC& allocator) noexcept(std::is_nothrow_constructible<vector<uint8_t, ALLOC>, const vector<uint8_t, ALLOC>&, const ALLOC&>::value);
    BasicBitBuffer& operator=(const BasicBitBuffer<ALLOC>&) = default;

    BasicBitBuffer(BasicBitBuffer<ALLOC>&&) = default;
    BasicBitBuffer(BasicBitBuffer<ALLOC>&& other, const ALLOC& allocator) noexcept(std::is_nothrow_constructible<vector<uint8_t, ALLOC>, vector<uint8_t, ALLOC>&&, const ALLOC&>::value);
    BasicBitBuffer& operator=(BasicBitBuffer<ALLOC>&&) = default;
    /**
     * \}
     */

    /**
     * Equal operator.
     *
     * \param other The another instance of bit buffer to which compare this bit buffer.
     *
     * \return True when the bit buffers have same contents, false otherwise.
     */
    bool operator==(const BasicBitBuffer<ALLOC>& other) const noexcept;

    /**
     * Operator less than.
     *
     * \param other The another instance of bit buffer to which compare this bit buffer.
     *
     * \return True when this bit buffer is less than the other (using lexicographical compare).
     */
    bool operator<(const BasicBitBuffer<ALLOC>& other) const noexcept;

    /**
     * Calculates hash code of the bit buffer.
     *
     * \return Calculated hash code.
     */
    uint32_t hashCode() const noexcept;

    /**
     * Gets the underlying buffer.
     *
     * \return Pointer to the constant underlying buffer.
     */
    const uint8_t* getBuffer() const noexcept;

    /**
     * Gets the underlying buffer.
     *
     * \return Pointer to the underlying buffer.
     */
    uint8_t* getBuffer() noexcept;

    /**
     * Gets the number of bits stored in the bit buffer.
     *
     * \return Bit buffer size in bits.
     */
    size_t getBitSize() const noexcept;

    /**
     * Gets the number of bytes stored in the bit buffer.
     *
     * Not all bits of the last byte must be used. Unused bits of the last byte are set to zero.
     *
     * \return Bit buffer size in bytes.
     */
    size_t getByteSize() const noexcept;

    /**
     * Convenience getter for the underlying buffer.
     *
     * \return Reference to the underlying vector of bytes.
     */
    const vector<uint8_t, ALLOC>& getBytes() const noexcept;

    /**
     * Convenience getter for the underlying buffer.
     *
     * \return The span to the underlying vector of bytes.
     */
    Span<const uint8_t> getData() const noexcept;

    /**
     * Convenience getter for the underlying buffer.
     *
     * \return The span to the underlying vector of bytes.
     */
    Span<uint8_t> getData() noexcept;

    /**
     * Safely resize the bit buffer.
     *
     * \param newBitSize New size in bits.
     * \return Result with success or error code on failure.
     */
    Result<void> resize(size_t newBitSize) noexcept;

    /**
     * Safely get byte at given index with bounds checking.
     *
     * \param byteIndex Index of the byte to retrieve.
     * \return Result containing the byte value or error code on failure.
     */
    Result<uint8_t> getByteAt(size_t byteIndex) const noexcept;

private:
    uint8_t getMaskedLastByte() const noexcept;

    vector<uint8_t, ALLOC> m_buffer;
    size_t m_bitSize;
};

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer() noexcept :
        m_buffer(ALLOC()),
        m_bitSize(0)
{}

template <typename ALLOC>
BasicBitBuffer<ALLOC>::BasicBitBuffer(const ALLOC& allocator) noexcept :
        m_buffer(allocator),
        m_bitSize(0)
{}

// Factory method implementations

template <typename ALLOC>
Result<BasicBitBuffer<ALLOC>> BasicBitBuffer<ALLOC>::create(size_t bitSize, const ALLOC& allocator) noexcept
{
    BasicBitBuffer<ALLOC> buffer(allocator);
    
    try
    {
        buffer.m_buffer.resize((bitSize + 7) / 8, 0);
        buffer.m_bitSize = bitSize;
        return Result<BasicBitBuffer<ALLOC>>::success(std::move(buffer));
    }
    catch (...)
    {
        return Result<BasicBitBuffer<ALLOC>>::error(ErrorCode::AllocationFailed);
    }
}

template <typename ALLOC>
Result<BasicBitBuffer<ALLOC>> BasicBitBuffer<ALLOC>::fromSpan(Span<const uint8_t> buffer, const ALLOC& allocator) noexcept
{
    BasicBitBuffer<ALLOC> bitBuffer(allocator);
    
    try
    {
        bitBuffer.m_buffer.assign(buffer.begin(), buffer.end());
        bitBuffer.m_bitSize = 8 * buffer.size();
        return Result<BasicBitBuffer<ALLOC>>::success(std::move(bitBuffer));
    }
    catch (...)
    {
        return Result<BasicBitBuffer<ALLOC>>::error(ErrorCode::AllocationFailed);
    }
}

template <typename ALLOC>
Result<BasicBitBuffer<ALLOC>> BasicBitBuffer<ALLOC>::fromSpan(Span<const uint8_t> buffer, size_t bitSize, const ALLOC& allocator) noexcept
{
    const size_t byteSize = (bitSize + 7) / 8;
    if (buffer.size() < byteSize)
    {
        return Result<BasicBitBuffer<ALLOC>>::error(ErrorCode::WrongBufferBitSize);
    }
    
    BasicBitBuffer<ALLOC> bitBuffer(allocator);
    
    try
    {
        bitBuffer.m_buffer.assign(buffer.begin(), buffer.end());
        bitBuffer.m_bitSize = bitSize;
        return Result<BasicBitBuffer<ALLOC>>::success(std::move(bitBuffer));
    }
    catch (...)
    {
        return Result<BasicBitBuffer<ALLOC>>::error(ErrorCode::AllocationFailed);
    }
}

template <typename ALLOC>
Result<BasicBitBuffer<ALLOC>> BasicBitBuffer<ALLOC>::fromVector(vector<uint8_t, ALLOC>&& buffer) noexcept
{
    BasicBitBuffer<ALLOC> bitBuffer;
    bitBuffer.m_buffer = std::move(buffer);
    bitBuffer.m_bitSize = 8 * bitBuffer.m_buffer.size();
    return Result<BasicBitBuffer<ALLOC>>::success(std::move(bitBuffer));
}

template <typename ALLOC>
Result<BasicBitBuffer<ALLOC>> BasicBitBuffer<ALLOC>::fromVector(vector<uint8_t, ALLOC>&& buffer, size_t bitSize) noexcept
{
    const size_t byteSize = (bitSize + 7) / 8;
    if (buffer.size() < byteSize)
    {
        return Result<BasicBitBuffer<ALLOC>>::error(ErrorCode::WrongBufferBitSize);
    }
    
    BasicBitBuffer<ALLOC> bitBuffer;
    bitBuffer.m_buffer = std::move(buffer);
    bitBuffer.m_bitSize = bitSize;
    return Result<BasicBitBuffer<ALLOC>>::success(std::move(bitBuffer));
}

template <typename ALLOC>
Result<BasicBitBuffer<ALLOC>> BasicBitBuffer<ALLOC>::fromBuffer(const uint8_t* buffer, size_t bitSize, const ALLOC& allocator) noexcept
{
    if (buffer == nullptr)
    {
        return Result<BasicBitBuffer<ALLOC>>::error(ErrorCode::NullPointer);
    }
    
    BasicBitBuffer<ALLOC> bitBuffer(allocator);
    
    try
    {
        const size_t byteSize = (bitSize + 7) / 8;
        bitBuffer.m_buffer.assign(buffer, buffer + byteSize);
        bitBuffer.m_bitSize = bitSize;
        return Result<BasicBitBuffer<ALLOC>>::success(std::move(bitBuffer));
    }
    catch (...)
    {
        return Result<BasicBitBuffer<ALLOC>>::error(ErrorCode::AllocationFailed);
    }
}

template <typename ALLOC>
inline BasicBitBuffer<ALLOC>::BasicBitBuffer(const BasicBitBuffer<ALLOC>& other, const ALLOC& allocator) noexcept(std::is_nothrow_constructible<vector<uint8_t, ALLOC>, const vector<uint8_t, ALLOC>&, const ALLOC&>::value) :
        m_buffer(other.m_buffer, allocator),
        m_bitSize(other.m_bitSize)
{}

template <typename ALLOC>
inline BasicBitBuffer<ALLOC>::BasicBitBuffer(BasicBitBuffer<ALLOC>&& other, const ALLOC& allocator) noexcept(std::is_nothrow_constructible<vector<uint8_t, ALLOC>, vector<uint8_t, ALLOC>&&, const ALLOC&>::value) :
        m_buffer(std::move(other.m_buffer), allocator),
        m_bitSize(other.m_bitSize)
{}

template <typename ALLOC>
bool BasicBitBuffer<ALLOC>::operator==(const BasicBitBuffer<ALLOC>& other) const noexcept
{
    if (this != &other)
    {
        if (m_bitSize != other.m_bitSize)
        {
            return false;
        }

        const size_t byteSize = getByteSize();
        if (byteSize > 0)
        {
            if (byteSize > 1)
            {
                if (memcmp(getBuffer(), other.getBuffer(), byteSize - 1) != 0)
                {
                    return false;
                }
            }

            if (getMaskedLastByte() != other.getMaskedLastByte())
            {
                return false;
            }
        }
    }

    return true;
}

template <typename ALLOC>
bool BasicBitBuffer<ALLOC>::operator<(const BasicBitBuffer<ALLOC>& other) const noexcept
{
    const size_t byteSize1 = getByteSize();
    const size_t byteSize2 = other.getByteSize();

    if (byteSize1 == 0)
    {
        return byteSize2 != 0;
    }
    if (byteSize2 == 0)
    {
        return false;
    }

    using difference_type = typename vector<uint8_t, ALLOC>::iterator::difference_type;

    auto first1 = m_buffer.begin();
    const auto last1 = first1 + static_cast<difference_type>(byteSize1 - 1);
    auto first2 = other.m_buffer.begin();
    const auto last2 = first2 + static_cast<difference_type>(byteSize2 - 1);
    for (; (first1 != last1) && (first2 != last2); ++first1, ++first2)
    {
        if (*first1 < *first2)
        {
            return true;
        }
        if (*first2 < *first1)
        {
            return false;
        }
    }

    const auto lastValue1 = first1 != last1 ? *first1 : getMaskedLastByte();
    const auto lastValue2 = first2 != last2 ? *first2 : other.getMaskedLastByte();
    if (lastValue1 < lastValue2)
    {
        return true;
    }
    if (lastValue2 < lastValue1)
    {
        return false;
    }

    return (first1 == last1) && (first2 != last2);
}

template <typename ALLOC>
uint32_t BasicBitBuffer<ALLOC>::hashCode() const noexcept
{
    uint32_t result = ::zserio::HASH_SEED;
    const size_t byteSize = getByteSize();
    if (byteSize > 0)
    {
        if (byteSize > 1)
        {
            auto lastIt = m_buffer.begin() + static_cast<int>(byteSize) - 1;
            for (auto it = m_buffer.begin(); it != lastIt; ++it)
            {
                result = calcHashCode(result, *it);
            }
        }
        result = ::zserio::calcHashCode(result, getMaskedLastByte());
    }

    return result;
}

template <typename ALLOC>
const uint8_t* BasicBitBuffer<ALLOC>::getBuffer() const noexcept
{
    return m_buffer.data();
}

template <typename ALLOC>
uint8_t* BasicBitBuffer<ALLOC>::getBuffer() noexcept
{
    return m_buffer.data();
}

template <typename ALLOC>
size_t BasicBitBuffer<ALLOC>::getBitSize() const noexcept
{
    return m_bitSize;
}

template <typename ALLOC>
size_t BasicBitBuffer<ALLOC>::getByteSize() const noexcept
{
    return (m_bitSize + 7) / 8;
}

template <typename ALLOC>
const vector<uint8_t, ALLOC>& BasicBitBuffer<ALLOC>::getBytes() const noexcept
{
    return m_buffer;
}

template <typename ALLOC>
Span<const uint8_t> BasicBitBuffer<ALLOC>::getData() const noexcept
{
    return Span<const uint8_t>(m_buffer);
}

template <typename ALLOC>
Span<uint8_t> BasicBitBuffer<ALLOC>::getData() noexcept
{
    return Span<uint8_t>(m_buffer);
}

// Safe operations implementations

template <typename ALLOC>
Result<void> BasicBitBuffer<ALLOC>::resize(size_t newBitSize) noexcept
{
    try
    {
        const size_t newByteSize = (newBitSize + 7) / 8;
        m_buffer.resize(newByteSize, 0);
        m_bitSize = newBitSize;
        return Result<void>::success();
    }
    catch (...)
    {
        return Result<void>::error(ErrorCode::AllocationFailed);
    }
}

template <typename ALLOC>
Result<uint8_t> BasicBitBuffer<ALLOC>::getByteAt(size_t byteIndex) const noexcept
{
    if (byteIndex >= m_buffer.size())
    {
        return Result<uint8_t>::error(ErrorCode::InvalidIndex);
    }
    
    return Result<uint8_t>::success(m_buffer[byteIndex]);
}

template <typename ALLOC>
uint8_t BasicBitBuffer<ALLOC>::getMaskedLastByte() const noexcept
{
    const size_t roundedByteSize = m_bitSize / 8;
    const uint8_t lastByteBits = static_cast<uint8_t>(m_bitSize - 8 * roundedByteSize);

    return (lastByteBits == 0)
            ? m_buffer[roundedByteSize - 1]
            : static_cast<uint8_t>(m_buffer[roundedByteSize] & (0xFFU << (8U - lastByteBits)));
}

/** Typedef to BitBuffer provided for convenience - using std::allocator<uint8_t>. */
using BitBuffer = BasicBitBuffer<>;

/**
 * Allows to append BitBuffer to CppRuntimeException.
 *
 * \param exception Exception to modify.
 * \param bitBuffer Bit buffer value.
 *
 * \return Reference to the exception to allow operator chaining.
 */
template <typename ALLOC>
CppRuntimeException& operator<<(CppRuntimeException& exception, const BasicBitBuffer<ALLOC>& bitBuffer)
{
    return exception << "BitBuffer([...], " << bitBuffer.getBitSize() << ")";
}

} // namespace zserio

#endif // ifndef ZSERIO_BIT_BUFFER_H_INC
