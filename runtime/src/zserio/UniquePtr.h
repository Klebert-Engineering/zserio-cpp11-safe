#ifndef ZSERIO_UNIQUE_PTR_H_INC
#define ZSERIO_UNIQUE_PTR_H_INC

#include <memory>
#include <type_traits>

#include "zserio/AllocatorHolder.h"
#include "zserio/RebindAlloc.h"
#include "zserio/Result.h"

namespace zserio
{

namespace detail
{

/**
 * Custom deleter to ensure proper deallocation of the unique_ptr.
 */
template <class ALLOC_T>
struct UniquePtrDeleter : public AllocatorHolder<ALLOC_T>
{
    using allocator_type = ALLOC_T;
    using T = typename allocator_type::value_type;

    /** Method generated by default. */
    /** \{ */
    ~UniquePtrDeleter() = default;

    UniquePtrDeleter(UniquePtrDeleter&& other) = default;
    UniquePtrDeleter& operator=(UniquePtrDeleter&& other) = default;
    /**
     * \}
     */

    /**
     * Copying is disallowed!
     * \{
     */
    UniquePtrDeleter(const UniquePtrDeleter& other) = delete;
    UniquePtrDeleter& operator=(const UniquePtrDeleter& other) = delete;
    /**
     * \}
     */

    /**
     * Empty constructor.
     */
    template <typename ALLOC_U = ALLOC_T>
    UniquePtrDeleter() :
            UniquePtrDeleter(ALLOC_U())
    {}

    /**
     * Constructor from given allocator.
     */
    template <typename ALLOC_U = ALLOC_T>
    UniquePtrDeleter(const ALLOC_U& allocator) :
            AllocatorHolder<ALLOC_T>(allocator)
    {
        static_assert(std::is_same<allocator_type, RebindAlloc<ALLOC_U, T>>::value,
                "UniquePtrDeleter requires same allocator in constructor!");
    }

    /**
     * Constructor from deleter to another type.
     */
    template <typename ALLOC_U>
    UniquePtrDeleter(const UniquePtrDeleter<ALLOC_U>& deleter) :
            UniquePtrDeleter(deleter.get_allocator())
    {}

    void operator()(T* ptr)
    {
        allocator_type alloc = this->get_allocator();
        using AllocTraits = std::allocator_traits<allocator_type>;
        AllocTraits::destroy(alloc, std::addressof(*ptr));
        AllocTraits::deallocate(alloc, ptr, 1);
    }
};

} // namespace detail

/**
 * Typedef to std::unique_ptr provided for convenience - using std::allocator.
 *
 * Uses custom deleter to ensure proper deallocation.
 */
template <typename T, typename ALLOC = std::allocator<T>>
using unique_ptr = std::unique_ptr<T, detail::UniquePtrDeleter<ALLOC>>;

/**
 * Allocates memory for an object of type T using given allocator and constructs it passing args to its
 * constructor.
 *
 * IMPORTANT: This function cannot guarantee exception safety without exceptions. If construction fails,
 * the behavior is implementation-defined. In safe mode, prefer pre-allocated memory pools or stack allocation.
 *
 * \param allocator Allocator to use.
 * \param args      List of elements passed to T's constructor.
 *
 * \return Result containing unique_ptr to the constructed object or error code on failure.
 */
template <typename T, typename ALLOC, class... Args>
Result<zserio::unique_ptr<T, RebindAlloc<ALLOC, T>>> allocate_unique(const ALLOC& allocator, Args&&... args) noexcept
{
    using Allocator = RebindAlloc<ALLOC, T>;
    using AllocTraits = std::allocator_traits<Allocator>;
    using UniquePtr = zserio::unique_ptr<T, Allocator>;

    Allocator typedAllocator = allocator;
    
    // Allocate memory
    typename AllocTraits::pointer ptr = nullptr;
    
    // Note: allocate() can throw std::bad_alloc, but with -fno-exceptions this becomes std::abort()
    // or undefined behavior depending on implementation. In safe environments, use pre-allocated pools.
    ptr = AllocTraits::allocate(typedAllocator, 1);
    if (ptr == nullptr)
    {
        return Result<UniquePtr>::error(ErrorCode::AllocationFailed);
    }
    
    // Construct object in-place
    // Note: construct() can also throw, same caveat applies
    AllocTraits::construct(typedAllocator, std::addressof(*ptr), std::forward<Args>(args)...);
    
    return Result<UniquePtr>::success(UniquePtr(std::addressof(*ptr), typedAllocator));
}

} // namespace zserio

#endif // ZSERIO_UNIQUE_PTR_H_INC
